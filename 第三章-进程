1.论述长期调度、中期调度和短期调度的差异
长期调度的进程会被保存到大量存储设备(一般为磁盘)的缓冲池，调用时，从磁盘缓冲池加载到内存，再从内存加载到CPU；短期调度的进程，是从进程状态为就绪态中选择进程，
再加载到CPU执行；两者的区别在于进程执行的频率，长期调度程序执行的频率低，在选择新进程执行上会花比较多的时间，通常为几分钟。而短期调度程序执行的频率非常高，，
通常每100ms至少执行一次，要保持高频率切换进程，花在进程选择上的时间会很少，一般会少于进程的执行时间。
而中期调度采用了一种交换策略，执行的进程可从内存换出，在恰当的时候又会被换入内存，并从中断处继续执行，目的是为了降低多道程度的执行程度，这种方式比较灵活，
内存紧张时，可换出进程，内存空闲时，进程有可被换入。

2.内核采取一些动作以便在两个进程之间进行上下文切换，请描述一下
要解释这个，我们先来说说为什么内核要切换进程。
现在的笔记本或者是手机，可以同时开多个应用，不知道大家有没有这样的体验，比如我可以边听某易音乐，边和相隔千里的大学室友，开着某Q语音，在召唤师峡谷上一日游。
中间只要不是网络差，几乎这3件事情是同时进行的，我能完整的听完一首歌，同时听到队友开团时的呐喊声，在键盘按下R的那一刻，技能也能完全跟上。
似乎这些事情同时进行的，几乎感觉不到它们有停顿下的时候。
我们可以把听音乐抽象成进程1，语音抽象成进程2，打游戏抽象成进程3，这3个进程确实是同时并行的运行在CPU的。说到并行，CPU并不是真的同时在运行多个进程，在某个时间段，
CPU只能执行一个进程，只不过切换进程的时间很短，是毫秒或者是微妙的级别，我们几乎是感觉不到CPU在切换进程执行的，所以我们感觉所有运用都是同时进行的。
以上，是为了方便解释进程切换的概念做的一个不严谨的比喻。
很多时候，运行在CPU的进程会发生系统中断事件。比如运行在CPU上的A进程需要等待一个IO事件，它只有得到这个IO资源之后，才能再执行进行下去，这个时候，内核不会让
进程A“占着茅坑不拉屎”，它会把进程A先换下来，让其他进程，比如B进程到CPU中执行，进程切换是通过中断机制实现。那么问题来了，假如进程A得到IO资源后，如何在CPU上被继续执行呢？
其实在进程A被挂起的时候，这个时候内核会保存进程A此时的执行状态，它是通过PCB块去记录这些信息的，包括CPU寄存器的值、进程状态和内存管理信息等。通常，是通过执行状态
保存，保存CPU当前状态；之后，状态恢复重新开始执行。这样进程A就能再次被执行。
切换CPU到另一个进程需要保存当前进程状态和恢复另一个进程状态，这个任务称为上下文切换。
进程间上下文切换简单的解释了以下，再来扯一扯PCB。
PCB，英文全称为PROCESS CONTROL BLOCK,翻译成中文就是 进程控制块，它也不是什么特别的东西，像LINUX系统，PCB底层的数据结构是用C语言的结构体实现的，然后内核
为了管理方便，用双向链表把这些PCB组织起来。PCB保存着很多有用的信息，比如进程状态、进程编号、程序计数器、寄存器、内存界限、打开文件列表等等，它其实保存着进程
用到的相关资源，要了解进程，首先要从PCB开始认识，至于上面提到的程序计数器、寄存器这些概念就要去了解计算机组成原理相关概念了。

3.针对UNIX和Linux系统的进程init在进程终止方面的作用，请解释下
进程init是系统的根进程，所有的孤儿进程都会被收录到init进程下。
当一个进程被终止时，操作系统释放其资源，不过，位于进程表中的条目还是存在的，直到它的父进程调用wait();这是因为进程表包含了进程的退出状态。当进程已经终止，
但是其父进程尚未调用wait(),这样的进程成为僵尸进程。不过这种状态非常短暂，一旦父进程调用了wait(),僵尸进程的进程标识和它在进程表中的条目就会释放。
如果父进程没有调用wait(),那么子进程就会成为孤儿进程。进程init会收录这些孤儿进程，定期调用wait(),以便收集孤儿进程的退出状态，并释放孤儿进程标识符和进程表条目。

